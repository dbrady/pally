#!/usr/bin/env ruby
require 'rubygems'
require 'yaml'
require 'trollop'
require 'rally_rest_api'

require File.expand_path(File.join(File.dirname(__FILE__), '..', 'lib', 'common.rb'))

# usage:
# pally [options] command <args>

opts = Trollop.options do
  opt :config, "Configuration file", :default => nil
  opt :username, "Username", :default => nil
  opt :password, "Password", :default => nil
  opt :project, "Project", :default => nil
  opt :iteration, "Iteration", :default => nil
  opt :dump, "dump", :type => :boolean, :default => false
end
args = ARGV.dup

# ----------------------------------------------------------------------
# Config file
if opts[:config]
  $config_file = opts[:config]
else 
  f1 = File.expand_path('~/.pally/pally.yml')
  f2 = File.expand_path(File.join(File.dirname(__FILE__), '..', 'config', 'pally.yml'))
  $config_file = File.exist?(f1) ? f1 : f2
end
raise "Config file does not exist: #{opts[:config]}" unless File.exists? $config_file
$config = YAML::load_file $config_file

[:username, :password].each do |arg|
  $config['login'][arg.to_s] = opts[arg] if opts[arg]
end

# ----------------------------------------------------------------------
# Crap that shouldn't even be in here but what ya gonna do
def login(username, password)
  @rally = RallyRestAPI.new :username => username, :password => password
end

def listable?(type)
  RallyRestAPI::ALLOWED_TYPES.include? type
end


# ----------------------------------------------------------------------
# Parse out command
command = args.shift
collection = args.shift

puts "COMMAND: #{command} #{collection}"
puts '-' * 80
case command.downcase
when 'list'
  login $config['login']['username'], $config['login']['password']
  if listable? collection
    puts @rally.find_all(collection).map {|i| "#{i.type}: #{i.name} | #{i.body}" }
    
  elsif collection == 'mytasks'
    tasks = @rally.find(:task, :fetch => true) do
      equal :owner, $config['login']['username']
      not_equal :state, 'Completed'
    end

    tasks_by_project = Hash.new { |h,k| h[k] = []}
    tasks.each do |t|
      tasks_by_project[t.project.name] << t
    end
    # DRY this up! Get the max length of each desired column.
    plen = ["Project".size, tasks_by_project.keys.map{|k| k.size}.max].max
    slen = ["State".size, tasks_by_project.values.map{|vv| vv.map {|v| v.state.size}.max}.max].max
    fidlen = ["ID".size,tasks_by_project.values.map{|vv| vv.map {|v| v.formatted_i_d.size}.max}.max].max
    iterlen = ["Iteration".size,tasks_by_project.values.map{|vv| vv.map {|v| (v.iteration && v.iteration.name.size)||0}.max}.max].max
    estlen = ["Est".size,tasks_by_project.values.map{|vv| vv.map {|v| (v.estimate||"").size}.max}.max].max
    todolen = ["ToDo".size,tasks_by_project.values.map{|vv| vv.map {|v| (v.to_do||"").size}.max}.max].max
    
    puts "%#{plen}s | %#{iterlen}s | %#{fidlen}s | %#{estlen}s | %#{todolen}s | %#{slen}s | %s" % ["Project", "Iteration", "ID", "Est", "ToDo", "State", "Task"]
    tasks_by_project.each do |project, tasks|
      tasks.each do |task|
        puts "%#{plen}s | %#{iterlen}s | %#{fidlen}s | %#{estlen}s | %#{todolen}s | %#{slen}s | %s" % [task.project, (task.iteration ? task.iteration.name : ""), task.formatted_i_d, task.estimate, task.to_do, task.state, task.name]
        puts task.body if opts[:dump]
      end
    end
    
  else
    raise "LIST: unrecognized list type. Got #{collection.inspect}, expected one of [#{RallyRestAPI::ALLOWED_TYPES * ', '}]"
  end
else
  raise "Unrecognized command: #{command}"
end




